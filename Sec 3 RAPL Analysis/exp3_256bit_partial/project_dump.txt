--- PROJECT DUMP START ---
== 1. FILE LIST ==
.:
App.cpp
collate_project.sh
Enclave.c
Enclave.config.xml
Enclave.edl
gen_key_header.py
key.h
Makefile
prep_dir.sh
private.pem
project_dump.txt

include
lib

mbedtls

aes.h
aesni.h
arc4.h
asn1.h
asn1write.h
base64.h
bignum.h
blowfish.h
bn_mul.h
camellia.h
ccm.h
certs.h
check_config.h
cipher.h
cipher_internal.h
cmac.h
compat-1.3.h
config.h
ctr_drbg.h
debug.h
des.h
dhm.h
ecdh.h
ecdsa.h
ecjpake.h
ecp.h
ecp_internal.h
entropy.h
entropy_poll.h
error.h
gcm.h
glue.h
havege.h
hmac_drbg.h
md2.h
md4.h
md5.h
md.h
md_internal.h
memory_buffer_alloc.h
net.h
net_sockets.h
oid.h
padlock.h
pem.h
pkcs11.h
pkcs12.h
pkcs5.h
pk.h
pk_internal.h
platform.h
platform_time.h
ripemd160.h
rsa.h
sha1.h
sha256.h
sha512.h
ssl_cache.h
ssl_ciphersuites.h
ssl_cookie.h
ssl.h
ssl_internal.h
ssl_ticket.h
threading.h
timing.h
version.h
x509_crl.h
x509_crt.h
x509_csr.h
x509.h
xtea.h

libmbedtls_SGX_t.a
libmbedtls_SGX_u.a
mbedtls_SGX.edl

== 2. Enclave.edl ==
enclave {
    from "mbedtls_SGX.edl" import *;
    trusted {
        // Initializes the key once
        public int ecall_setup_key();

        // Performs the signing loop
        public int ecall_rsa_sign_benchmark(
            [in, size=msg_len] const unsigned char* msg, 
            size_t msg_len, 
            [out, size=sig_len] unsigned char* sig, 
            size_t sig_len,
            uint32_t iterations
        );
    };
};
== 3. Enclave.c ==
#include "Enclave_t.h"
#include "mbedtls/rsa.h"
#include "mbedtls/md.h"
#include "mbedtls/bignum.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/entropy.h"
#include "key.h"

// Persistent contexts
static mbedtls_rsa_context global_rsa;
static mbedtls_ctr_drbg_context global_ctr_drbg;
static mbedtls_entropy_context global_entropy;
static int is_initialized = 0;

int ecall_setup_key() {
    int ret;
    mbedtls_rsa_init(&global_rsa, MBEDTLS_RSA_PKCS_V15, MBEDTLS_MD_SHA256);
    mbedtls_ctr_drbg_init(&global_ctr_drbg);
    mbedtls_entropy_init(&global_entropy);

    ret = mbedtls_ctr_drbg_seed(&global_ctr_drbg, mbedtls_entropy_func, &global_entropy, NULL, 0);
    if (ret != 0) return ret;

    // Load all components
    mbedtls_mpi_read_binary(&global_rsa.N, rsa_n, rsa_n_len);
    mbedtls_mpi_read_binary(&global_rsa.E, rsa_e, rsa_e_len);
    mbedtls_mpi_read_binary(&global_rsa.D, rsa_d, rsa_d_len);
    mbedtls_mpi_read_binary(&global_rsa.P, rsa_p, rsa_p_len);
    mbedtls_mpi_read_binary(&global_rsa.Q, rsa_q, rsa_q_len);
    global_rsa.len = mbedtls_mpi_size(&global_rsa.N);

    ret = mbedtls_rsa_check_privkey(&global_rsa);
    if (ret == 0) is_initialized = 1;
    return ret;
}

int ecall_rsa_sign_benchmark(const unsigned char* msg, size_t msg_len, unsigned char* sig, size_t sig_len, uint32_t iterations) {
    if (!is_initialized) return -1;

    unsigned char hash[32];
    int ret = 0;

    // Pre-hash the message once (unless you want to measure hashing energy too)
    mbedtls_md(mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), msg, msg_len, hash);

    // THE WORK LOOP
    // This is what RAPL will capture
    for (uint32_t i = 0; i < iterations; i++) {
        ret = mbedtls_rsa_pkcs1_sign(&global_rsa, 
                                     mbedtls_ctr_drbg_random, &global_ctr_drbg, 
                                     MBEDTLS_RSA_PRIVATE, 
                                     MBEDTLS_MD_SHA256, 32, hash, sig);
        if (ret != 0) break;
    }

    return ret;
}
== 4. App.cpp ==
#include <iostream>
#include <fcntl.h>
#include <unistd.h>
#include <cmath>
#include <chrono>
#include <vector>
#include "sgx_urts.h"
#include "Enclave_u.h"

// MSR Register Addresses
#define MSR_RAPL_POWER_UNIT    0x606
#define MSR_PP0_ENERGY_STATUS  0x639  // Core domain energy
#define MSR_PKG_ENERGY_STATUS  0x611  // Package energy (backup)

/**
 * Reads a 64-bit MSR from a specific CPU core
 */
uint64_t read_msr(int cpu, uint32_t reg) {
    char path[32];
    sprintf(path, "/dev/cpu/%d/msr", cpu);
    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror("\n[!] Error: Cannot open MSR file. Run: sudo modprobe msr");
        exit(1);
    }
    uint64_t data;
    if (pread(fd, &data, sizeof(data), reg) != sizeof(data)) {
        perror("\n[!] Error: Failed to read MSR. Are you running as root?");
        exit(1);
    }
    close(fd);
    return data;
}

/**
 * Calculates the Joule multiplier from the Power Unit MSR
 */
double get_energy_unit() {
    uint64_t unit_raw = read_msr(0, MSR_RAPL_POWER_UNIT);
    uint32_t esu = (unit_raw >> 8) & 0x1F; // Bits 12:8
    return 1.0 / pow(2, esu);
}

int main(int argc, char const *argv[]) {
    sgx_enclave_id_t eid = 0;
    sgx_launch_token_t token = {0};
    int updated = 0;
    sgx_status_t status;
    int enclave_ret = 0;

    // 1. Initialize Enclave
    status = sgx_create_enclave("enclave.signed.so", SGX_DEBUG_FLAG, &token, &updated, &eid, NULL);
    if (status != SGX_SUCCESS) {
        printf("Enclave creation failed: 0x%x\n", status);
        return 1;
    }

    // 2. Setup Key (Provisioning - not timed)
    printf("[+] Provisioning RSA key inside enclave...\n");
    ecall_setup_key(eid, &enclave_ret);
    if (enclave_ret != 0) {
        printf("Key setup failed: 0x%x\n", enclave_ret);
        return 1;
    }

    // 3. Prepare Benchmark Parameters
    const char* message = "PLATYPUS_TEST_VECTOR_0123456789";
    unsigned char signature[256] = {0};
    uint32_t iterations = 20000; // High count to overcome RAPL quantization
    double energy_unit = get_energy_unit();

    printf("[+] Energy Unit: %.12f Joules/tick\n", energy_unit);
    printf("[+] Starting benchmark: %u iterations of RSA-2048 signing...\n", iterations);

    // 4. MEASUREMENT START
    // We read Core Energy (PP0)
    uint64_t start_tick = read_msr(0, MSR_PP0_ENERGY_STATUS);
    auto start_time = std::chrono::high_resolution_clock::now();

    // Perform the loop inside the enclave
    status = ecall_rsa_sign_benchmark(eid, &enclave_ret, 
                                      (const unsigned char*)message, strlen(message), 
                                      signature, 256, iterations);

    // 5. MEASUREMENT END
    auto end_time = std::chrono::high_resolution_clock::now();
    uint64_t end_tick = read_msr(0, MSR_PP0_ENERGY_STATUS);

    if (status != SGX_SUCCESS || enclave_ret != 0) {
        printf("Benchmark ECALL failed! Status: 0x%x, Ret: %d\n", status, enclave_ret);
        return 1;
    }

    // 6. Data Analysis
    uint64_t delta_ticks = end_tick - start_tick;
    double total_energy_j = delta_ticks * energy_unit;
    std::chrono::duration<double> duration = end_time - start_time;
    
    double energy_per_sign_uj = (total_energy_j * 1000000.0) / iterations;
    double avg_power_w = total_energy_j / duration.count();

    printf("\n================= RESEARCH REPORT =================\n");
    printf("Target Domain:       PP0 (CPU Cores)\n");
    printf("Total Iterations:    %u\n", iterations);
    printf("Total Time:          %.4f seconds\n", duration.count());
    printf("Total Energy used:   %.6f Joules\n", total_energy_j);
    printf("---------------------------------------------------\n");
    printf("Avg Energy per Sign: %.4f micro-Joules (uJ)\n", energy_per_sign_uj);
    printf("Average Power Draw:  %.4f Watts\n", avg_power_w);
    printf("Throughput:          %.2f signs/second\n", iterations / duration.count());
    printf("===================================================\n");

    sgx_destroy_enclave(eid);
    return 0;
}

== 5. Makefile ==
SGX_SDK ?= /opt/intel/sgxsdk
MBEDTLS_SGX_DIR = ./mbedtls_SGX-2.6.0

# Paths
SGX_LIBRARY_PATH := $(SGX_SDK)/lib64
SGX_ENCLAVE_SIGNER := $(SGX_SDK)/bin/x64/sgx_sign
SGX_EDGER8R := $(SGX_SDK)/bin/x64/sgx_edger8r

# Flags for App
App_C_Flags := -fPIC -Wno-attributes -I$(SGX_SDK)/include -I$(MBEDTLS_SGX_DIR)/include
App_Link_Flags := -L$(SGX_LIBRARY_PATH) -lsgx_urts -lpthread -L$(MBEDTLS_SGX_DIR)/lib -lmbedtls_SGX_u

# Flags for Enclave
Enclave_C_Flags := -static -nostdinc -fvisibility=hidden -fPIC -fstack-protector \
                   -I$(SGX_SDK)/include -I$(SGX_SDK)/include/tlibc -I$(MBEDTLS_SGX_DIR)/include

Enclave_Link_Flags := -Wl,--no-undefined -nostdlib -nodefaultlibs -nostartfiles -L$(SGX_LIBRARY_PATH) \
    -Wl,--whole-archive -lsgx_trts -Wl,--no-whole-archive \
    -Wl,--start-group -L$(MBEDTLS_SGX_DIR)/lib -lmbedtls_SGX_t -lsgx_tstdc -lsgx_tcxx -lsgx_tservice -lsgx_tcrypto -Wl,--end-group \
    -Wl,-Bstatic -Wl,-Bsymbolic -Wl,--no-undefined \
    -Wl,-shared,-eenclave_entry -Wl,--export-dynamic \
    -Wl,--defsym,__ImageBase=0

all: enclave.signed.so app

# Build App
Enclave_u.c: Enclave.edl
	$(SGX_EDGER8R) --untrusted Enclave.edl --search-path $(MBEDTLS_SGX_DIR)/lib --search-path $(SGX_SDK)/include

app: Enclave_u.c App.cpp
	g++ $(App_C_Flags) $^ -o $@ $(App_Link_Flags)

# Build Enclave
Enclave_t.c: Enclave.edl
	$(SGX_EDGER8R) --trusted Enclave.edl --search-path $(MBEDTLS_SGX_DIR)/lib --search-path $(SGX_SDK)/include

Enclave_t.o: Enclave_t.c
	gcc $(Enclave_C_Flags) -c $< -o $@

Enclave.o: Enclave.c
	gcc $(Enclave_C_Flags) -c $< -o $@

enclave.so: Enclave_t.o Enclave.o
	g++ $^ -o $@ $(Enclave_Link_Flags)

enclave.signed.so: enclave.so
	$(SGX_ENCLAVE_SIGNER) sign -key Enclave_private.pem -enclave enclave.so -out $@ -config Enclave.config.xml || \
	(openssl genrsa -3 -out Enclave_private.pem 3072 && $(SGX_ENCLAVE_SIGNER) sign -key Enclave_private.pem -enclave enclave.so -out $@ -config Enclave.config.xml)

clean:
	rm -f app enclave.so enclave.signed.so Enclave_t.* Enclave_u.* *.o Enclave_private.pem
== 6. key.h structure (Byte counts) ==
static const size_t rsa_n_len = 256;
static const size_t rsa_e_len = 3;
static const size_t rsa_d_len = 256;
static const size_t rsa_p_len = 128;
static const size_t rsa_q_len = 128;
static const size_t rsa_dp_len = 128;
static const size_t rsa_dq_len = 128;
static const size_t rsa_qp_len = 128;

== 7. key.h actual data ==
#ifndef RSA_KEY_H
#define RSA_KEY_H

static const unsigned char rsa_n[] = { 0xd9, 0xc4, 0x69, 0xf8, 0x30, 0xdf, 0xd2, 0x5a, 0xd6, 0x95, 0x1f, 0xcf, 0x30, 0x93, 0xd9, 0xb1, 0xda, 0x33, 0x3b, 0x5d, 0xae, 0xaf, 0x31, 0x1a, 0x2f, 0xaf, 0x45, 0x12, 0xa2, 0x68, 0x82, 0x16, 0x24, 0xd9, 0xb7, 0x85, 0x23, 0x7b, 0x67, 0x02, 0x8a, 0xb1, 0x58, 0x9c, 0xdd, 0x7a, 0x30, 0x72, 0x14, 0x6d, 0x98, 0x0f, 0x97, 0x6b, 0x38, 0x21, 0xe8, 0x33, 0x24, 0x1f, 0x9f, 0x52, 0x64, 0x49, 0xfd, 0x42, 0x10, 0x77, 0xc2, 0xc5, 0xef, 0x39, 0x4f, 0x7a, 0xb7, 0x4e, 0xdf, 0xdf, 0xb7, 0xd0, 0x57, 0x93, 0xf7, 0x1f, 0xf2, 0xac, 0xef, 0xf7, 0xc2, 0xfc, 0xf8, 0x88, 0xa3, 0xb1, 0x7b, 0x2a, 0x77, 0xf0, 0x1f, 0x40, 0xce, 0x7e, 0xab, 0x11, 0x1a, 0xc1, 0xa4, 0xf5, 0x96, 0xfb, 0xe9, 0x55, 0x7a, 0xc8, 0xf1, 0xef, 0x19, 0x69, 0x33, 0x47, 0xbb, 0xf9, 0x32, 0xdf, 0x6b, 0x5c, 0xf1, 0xfd, 0x3b, 0xad, 0x11, 0x4e, 0x5a, 0x86, 0x8d, 0x26, 0x3c, 0xf9, 0xb5, 0xda, 0xb2, 0xab, 0x72, 0x8c, 0xe7, 0x42, 0xc9, 0x2a, 0xce, 0x34, 0xc0, 0xf9, 0x7f, 0x06, 0x47, 0xce, 0xeb, 0xaa, 0x34, 0xf3, 0xb3, 0x1b, 0xa0, 0x45, 0x60, 0x25, 0xef, 0x60, 0x71, 0x66, 0x83, 0xa5, 0xe9, 0x54, 0xe8, 0x91, 0x99, 0xab, 0xb6, 0xc3, 0x4b, 0x80, 0x32, 0xd2, 0x3b, 0x11, 0x92, 0x84, 0xce, 0x1a, 0x41, 0x3b, 0x96, 0xa6, 0x85, 0x5c, 0x6a, 0xec, 0xc9, 0x97, 0xd8, 0x38, 0x1e, 0x4e, 0x97, 0xaf, 0x46, 0xc1, 0xdc, 0x22, 0x10, 0xdc, 0xe5, 0x63, 0x11, 0xe7, 0xc7, 0x3d, 0x82, 0xb2, 0x58, 0x6e, 0x5e, 0xc6, 0x86, 0x3a, 0x25, 0x39, 0x63, 0x5c, 0xe8, 0xff, 0xc0, 0xd0, 0x9c, 0x99, 0x7e, 0xb4, 0x8b, 0x51, 0x60, 0x17, 0x6a, 0x80, 0x94, 0x66, 0xd2, 0xcc, 0xce, 0xf4, 0x00, 0x00, 0x88, 0xc5, 0x64, 0xd5 };
static const size_t rsa_n_len = 256;

static const unsigned char rsa_e[] = { 0x01, 0x00, 0x01 };
static const size_t rsa_e_len = 3;

static const unsigned char rsa_d[] = { 0x5e, 0x87, 0x03, 0xf8, 0xd8, 0x3e, 0x4f, 0xf1, 0x5e, 0x74, 0x1c, 0xfa, 0xb2, 0xfb, 0x7a, 0xe3, 0xd8, 0xf3, 0xa4, 0x31, 0x66, 0x42, 0x65, 0xee, 0x18, 0x04, 0xdc, 0xd6, 0xd9, 0xe8, 0xc3, 0x8f, 0x19, 0x2f, 0xe8, 0x99, 0xc2, 0x6d, 0x2e, 0xa9, 0xcb, 0xca, 0x6f, 0xcc, 0xa7, 0xd7, 0x02, 0x70, 0x82, 0xad, 0x8f, 0xf4, 0x34, 0xa6, 0x36, 0x17, 0x81, 0xd3, 0xb1, 0x3a, 0x88, 0xce, 0x1a, 0xfa, 0x83, 0x14, 0xca, 0x51, 0x32, 0x1a, 0xf9, 0x5c, 0xc7, 0x43, 0x5d, 0x8e, 0xbf, 0x5f, 0x3d, 0x4b, 0x12, 0xb9, 0x07, 0xec, 0xb6, 0x4a, 0x9b, 0x5f, 0xd1, 0x24, 0x3e, 0x3e, 0x11, 0xd0, 0x58, 0xc6, 0x76, 0x89, 0xa5, 0x07, 0x5c, 0x9b, 0x5f, 0x66, 0x6d, 0x56, 0xe1, 0x64, 0x39, 0xc5, 0xdf, 0xe3, 0x5b, 0x09, 0x1e, 0xfb, 0xca, 0xeb, 0xff, 0x76, 0x84, 0x02, 0x08, 0x33, 0x33, 0x47, 0x85, 0x42, 0xb9, 0xac, 0x0b, 0xfa, 0x5a, 0xbe, 0xfa, 0x52, 0x1b, 0x4a, 0x3b, 0x88, 0x67, 0x9a, 0x56, 0xfc, 0x22, 0x0e, 0xf9, 0xc8, 0xd4, 0x7e, 0x00, 0x1b, 0x48, 0xed, 0x7a, 0x2f, 0x49, 0xbc, 0x69, 0x4a, 0x46, 0xc3, 0x09, 0x8a, 0xd5, 0xfb, 0x8f, 0x06, 0x7e, 0x3f, 0xc4, 0x06, 0x6c, 0x38, 0x39, 0x63, 0x24, 0xfd, 0x97, 0xb7, 0x9d, 0xc1, 0x13, 0x9b, 0xe3, 0xd1, 0x02, 0x51, 0xd6, 0x38, 0xef, 0xa3, 0x33, 0x73, 0xdc, 0xab, 0xc4, 0x66, 0x01, 0xd5, 0xcf, 0x1b, 0x68, 0x2e, 0xd9, 0x46, 0x1c, 0x78, 0x2a, 0xd1, 0xaf, 0x61, 0xee, 0xab, 0xfb, 0xa3, 0xa4, 0xd7, 0xa5, 0x7c, 0xf1, 0x53, 0x89, 0x2b, 0x53, 0x8e, 0x13, 0xd3, 0xab, 0xf6, 0xaa, 0x47, 0x0f, 0xb6, 0xfb, 0x97, 0x1c, 0xcb, 0xed, 0x10, 0x08, 0xe3, 0x58, 0x85, 0x53, 0x16, 0x27, 0xa7, 0x49, 0xf4, 0x63, 0x6f, 0x63, 0x29, 0x99, 0x81 };
static const size_t rsa_d_len = 256;

static const unsigned char rsa_p[] = { 0xff, 0x19, 0x47, 0xad, 0x4b, 0x83, 0xa8, 0xef, 0xce, 0x19, 0x66, 0x21, 0xfb, 0x4b, 0x31, 0x8a, 0x19, 0xce, 0xad, 0xc8, 0x5b, 0xa2, 0x26, 0x41, 0x4b, 0xec, 0x69, 0x62, 0x11, 0x8a, 0x05, 0xa4, 0x31, 0x50, 0x36, 0x07, 0x1a, 0x44, 0x74, 0xc4, 0x16, 0x62, 0x1a, 0xf2, 0x17, 0x05, 0x18, 0x59, 0x9f, 0xcf, 0x89, 0x46, 0x65, 0xb5, 0xaa, 0x74, 0x50, 0xc6, 0x02, 0x3e, 0x68, 0xf8, 0x2d, 0xf4, 0xb7, 0xd5, 0x79, 0xda, 0x26, 0x99, 0x67, 0x83, 0x3c, 0x2b, 0xa0, 0x31, 0x2d, 0x55, 0x0a, 0xef, 0x2c, 0x4e, 0xc9, 0xbe, 0xad, 0xad, 0xe9, 0x2d, 0x37, 0xc6, 0xef, 0x0a, 0xf8, 0x11, 0x33, 0xef, 0x36, 0x22, 0x74, 0xa0, 0x16, 0xe7, 0xd0, 0x0c, 0xfc, 0xd6, 0xe7, 0x39, 0x6f, 0xbf, 0x56, 0xce, 0xdc, 0x13, 0xfe, 0x03, 0x26, 0xc5, 0x2e, 0xa3, 0x1b, 0xdf, 0xaf, 0xca, 0xef, 0x34, 0xc5, 0x1f };
static const size_t rsa_p_len = 128;

static const unsigned char rsa_q[] = { 0xda, 0x89, 0x5e, 0xbc, 0xa4, 0x86, 0x4d, 0x2a, 0x6e, 0x9f, 0x06, 0xb2, 0xed, 0xc6, 0xc8, 0x26, 0xdc, 0x53, 0xe4, 0x75, 0x09, 0x67, 0x83, 0x2a, 0xba, 0x5d, 0x83, 0x2b, 0x72, 0xed, 0xe8, 0x69, 0x47, 0x81, 0x8c, 0xac, 0x91, 0x45, 0x11, 0xc5, 0xfd, 0xa9, 0x1a, 0x9b, 0xc6, 0x3a, 0xbd, 0xd4, 0xa4, 0x9d, 0xb8, 0x18, 0x7e, 0x30, 0x9a, 0x89, 0x2f, 0xdd, 0xcb, 0x48, 0x30, 0xa0, 0x70, 0x52, 0xef, 0xe3, 0x0a, 0xa5, 0xf6, 0xfd, 0xcd, 0x3d, 0xa2, 0xce, 0x15, 0x34, 0x26, 0xc7, 0xc0, 0x97, 0x03, 0x3f, 0x07, 0x4d, 0x2c, 0x5a, 0x11, 0xd6, 0xc6, 0xcb, 0x6e, 0xe5, 0xa8, 0xc8, 0x56, 0xe8, 0xe8, 0x7c, 0x1f, 0x73, 0x00, 0x57, 0x86, 0x65, 0x24, 0x2c, 0x49, 0xd6, 0x7a, 0xea, 0xbf, 0xeb, 0xb6, 0x85, 0x48, 0x6a, 0x9b, 0x2b, 0x9f, 0x94, 0x16, 0x77, 0x40, 0xa0, 0x16, 0x51, 0x03, 0x8b };
static const size_t rsa_q_len = 128;

static const unsigned char rsa_dp[] = { 0xb9, 0x94, 0x6d, 0x85, 0x8f, 0xa3, 0x17, 0x7a, 0x65, 0x68, 0x2a, 0xd9, 0xdb, 0xd3, 0xa7, 0x15, 0x7d, 0x92, 0xd2, 0xf0, 0x28, 0x61, 0x7d, 0x0d, 0x11, 0xab, 0xca, 0x3a, 0x92, 0xe1, 0xe3, 0x1a, 0xc0, 0xd9, 0x46, 0x84, 0xc2, 0x42, 0x3c, 0xe4, 0x0e, 0x18, 0x8e, 0xdb, 0xc1, 0x8d, 0x6e, 0x5a, 0x7d, 0x1d, 0x61, 0x13, 0x7a, 0x98, 0xbf, 0x89, 0x60, 0xdd, 0xbb, 0xf2, 0x25, 0x31, 0x2f, 0x55, 0x91, 0x8b, 0x56, 0xdb, 0x32, 0x2b, 0x75, 0x97, 0x8e, 0x65, 0x7a, 0x63, 0x6c, 0x44, 0x2a, 0xf1, 0x36, 0x3d, 0x97, 0x1d, 0x05, 0x82, 0xb8, 0x58, 0xb1, 0xf4, 0x22, 0x20, 0xcb, 0xb8, 0xd0, 0x1c, 0x5d, 0x38, 0x91, 0xb9, 0x89, 0x10, 0x59, 0x55, 0xa9, 0x76, 0xb9, 0xbe, 0x1a, 0x22, 0x8b, 0x87, 0x6f, 0xa9, 0x87, 0xa8, 0x49, 0x43, 0x37, 0x9b, 0x67, 0x82, 0xc2, 0x83, 0x92, 0xa3, 0xc4, 0x27 };
static const size_t rsa_dp_len = 128;

static const unsigned char rsa_dq[] = { 0x5c, 0xf3, 0x5e, 0xd3, 0x37, 0xdb, 0x53, 0xc8, 0xff, 0x82, 0x2e, 0x54, 0x3e, 0xa4, 0x75, 0x0f, 0x6a, 0x59, 0x58, 0x6b, 0x9b, 0x53, 0x66, 0xcb, 0xee, 0xb6, 0xc5, 0x8a, 0xde, 0x78, 0x68, 0x89, 0x16, 0xfb, 0xf8, 0x3c, 0x92, 0x11, 0x61, 0xac, 0xe7, 0xe6, 0x5c, 0x45, 0xf3, 0x7b, 0x9a, 0xb0, 0x6e, 0x50, 0x13, 0x34, 0x7f, 0xbf, 0xe6, 0x8b, 0x01, 0x4c, 0x02, 0x21, 0xb3, 0x65, 0x1a, 0x41, 0x7c, 0x7d, 0x02, 0x53, 0x73, 0x09, 0xa2, 0x99, 0x5b, 0xbc, 0xf1, 0xf1, 0xdb, 0xa8, 0xcc, 0xb6, 0xae, 0x8f, 0xc9, 0x68, 0x3e, 0xbc, 0x14, 0xa8, 0x58, 0xa7, 0xc0, 0x84, 0x78, 0x54, 0xb5, 0xfa, 0x9c, 0x9f, 0xe6, 0xb4, 0x80, 0x69, 0xb9, 0xe5, 0x1d, 0x0c, 0xa5, 0x5f, 0x4f, 0xaa, 0xb7, 0x74, 0xe7, 0x8e, 0x2b, 0x2e, 0x04, 0xcf, 0xfa, 0x30, 0xff, 0x99, 0x3b, 0x68, 0x9b, 0xf5, 0x5b, 0x5f };
static const size_t rsa_dq_len = 128;

static const unsigned char rsa_qp[] = { 0x6b, 0x62, 0x99, 0x5d, 0xa2, 0xdb, 0x88, 0x1b, 0xb6, 0xe8, 0x68, 0x62, 0xa6, 0x02, 0x25, 0xbd, 0x3a, 0x6e, 0x69, 0x22, 0x81, 0x35, 0x1a, 0xbe, 0x9c, 0x7c, 0xbb, 0xed, 0x5a, 0x88, 0x19, 0x52, 0x7a, 0x62, 0x5b, 0xee, 0x53, 0x00, 0x17, 0x6c, 0x4a, 0xf0, 0x91, 0x50, 0xc9, 0x0d, 0x67, 0xa2, 0x72, 0x80, 0x4c, 0xc5, 0x0d, 0xb4, 0x0a, 0x95, 0xbb, 0xe2, 0x68, 0x94, 0x83, 0xe4, 0xa8, 0xcb, 0x21, 0xe9, 0xca, 0x10, 0x56, 0x40, 0xd8, 0x59, 0x31, 0x14, 0xf1, 0x02, 0x05, 0x1d, 0x64, 0x50, 0xbe, 0x07, 0x4e, 0xc8, 0xbd, 0x22, 0x78, 0x4d, 0x37, 0x73, 0xa9, 0xf3, 0x03, 0x5c, 0x4e, 0x2a, 0xc3, 0x2f, 0x90, 0xf5, 0x72, 0x55, 0x38, 0x54, 0x11, 0x3f, 0x7a, 0x61, 0xca, 0xac, 0x32, 0x84, 0x10, 0xc8, 0xdc, 0x72, 0x11, 0x2c, 0x7a, 0x16, 0x73, 0x7b, 0xe3, 0xba, 0xdd, 0x0f, 0x40, 0x4f };
static const size_t rsa_qp_len = 128;

#endif
--- PROJECT DUMP END ---
